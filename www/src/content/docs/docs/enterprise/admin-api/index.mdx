---
title: Admin API Overview
description: Server-to-server APIs for managing users, sessions, and resources programmatically.
---

The Admin API provides secure, server-to-server endpoints for programmatic management of your authentication system. These APIs are designed for backend services, admin dashboards, and automation workflows.

## What are Admin APIs?

Admin APIs are RESTful endpoints that allow you to:

- **Manage Users** - Create, update, suspend, and delete user accounts
- **Control Sessions** - View and revoke user sessions across devices
- **Link Identities** - Connect multiple authentication providers to a single user
- **Query Data** - List and search through users with pagination and filtering

Unlike user-facing authentication flows, Admin APIs are meant for machine-to-machine (M2M) communication and require special authorization.

## Authentication

All Admin API requests require a valid **M2M access token** with appropriate scopes. These tokens are obtained through the OAuth 2.0 Client Credentials flow.

### Obtaining an M2M Token

```ts title="get-admin-token.ts"
const response = await fetch("https://auth.example.com/oauth/token", {
  method: "POST",
  headers: {
    "Content-Type": "application/json",
  },
  body: JSON.stringify({
    grant_type: "client_credentials",
    client_id: "your-admin-client-id",
    client_secret: "your-admin-client-secret",
    scope: "users:read users:write users:delete",
  }),
})

const { access_token } = await response.json()
```

### Using the Token

Include the access token in the `Authorization` header of all Admin API requests:

```ts title="api-request.ts"
const response = await fetch("https://auth.example.com/api/users", {
  headers: {
    Authorization: `Bearer ${access_token}`,
    "Content-Type": "application/json",
  },
})
```

## Base URL

Admin API endpoints are served from your OpenAuth issuer URL under the `/api` path:

```
https://auth.example.com/api/users
https://auth.example.com/api/users/:id
https://auth.example.com/api/users/:id/sessions
```

For multi-tenant deployments, the tenant context is determined automatically from the request (via domain, subdomain, or header) and all operations are scoped to that tenant.

## Common Patterns

### Cursor-Based Pagination

List endpoints use cursor-based pagination for efficient traversal of large datasets:

```ts title="pagination-example.ts"
interface PaginatedResponse<T> {
  items: T[]
  next_cursor: string | null
  has_more: boolean
  total_count?: number
}

// First page
const page1 = await fetch("/api/users?limit=50")

// Next page using cursor
const page2 = await fetch(`/api/users?limit=50&cursor=${page1.next_cursor}`)
```

**Query Parameters:**

| Parameter | Type | Default | Description |
|-----------|------|---------|-------------|
| `limit` | number | 50 | Number of items per page (max: 100) |
| `cursor` | string | - | Cursor for the next page |
| `sort_by` | string | `created_at` | Field to sort by |
| `sort_order` | string | `desc` | Sort direction (`asc` or `desc`) |

### Error Responses

All errors follow the OAuth 2.0 error response format:

```json title="error-response.json"
{
  "error": "user_not_found",
  "error_description": "User 'usr_abc123' not found"
}
```

**Validation errors** include the field that failed validation:

```json title="validation-error.json"
{
  "error": "validation_error",
  "error_description": "Invalid email format",
  "field": "email"
}
```

**HTTP Status Codes:**

| Status | Description |
|--------|-------------|
| 200 | Success |
| 201 | Created |
| 204 | No Content (successful delete) |
| 400 | Bad Request / Validation Error |
| 401 | Unauthorized (missing or invalid token) |
| 403 | Forbidden (insufficient scopes or user suspended/deleted) |
| 404 | Resource Not Found |
| 409 | Conflict (duplicate resource) |
| 429 | Rate Limited |
| 500 | Internal Server Error |

### Rate Limiting

Admin APIs include rate limiting headers in responses:

```http
X-RateLimit-Limit: 1000
X-RateLimit-Remaining: 999
X-RateLimit-Reset: 1699574400
```

When rate limited, you'll receive a `429` response:

```json
{
  "error": "rate_limit_exceeded",
  "error_description": "Too many requests. Retry after 60 seconds."
}
```

## Available APIs

| API | Base Path | Description |
|-----|-----------|-------------|
| [Users](/docs/enterprise/admin-api/users) | `/api/users` | Manage user accounts and identities |

## Required Scopes

Each API endpoint requires specific OAuth scopes. Your M2M client must be configured with the appropriate scopes:

| Scope | Description | Endpoints |
|-------|-------------|-----------|
| `users:read` | Read user data | `GET /api/users`, `GET /api/users/:id` |
| `users:write` | Create and update users | `POST /api/users`, `PATCH /api/users/:id`, `POST /api/users/:id/suspend`, `POST /api/users/:id/unsuspend` |
| `users:delete` | Delete users and sessions | `DELETE /api/users/:id`, `DELETE /api/users/:id/sessions` |

## Multi-Tenant Considerations

In multi-tenant deployments:

1. **Tenant Isolation** - All API operations are automatically scoped to the resolved tenant
2. **Tenant Resolution** - The tenant is determined from the request context (domain, subdomain, path, or header)
3. **Cross-Tenant Access** - Not supported; each tenant's data is completely isolated

```ts title="tenant-scoped-request.ts"
// Request to tenant-specific domain
const response = await fetch("https://acme.auth.example.com/api/users", {
  headers: {
    Authorization: `Bearer ${access_token}`,
  },
})

// Or using tenant header
const response = await fetch("https://auth.example.com/api/users", {
  headers: {
    Authorization: `Bearer ${access_token}`,
    "X-Tenant-ID": "acme",
  },
})
```

## SDK Usage

While the Admin API can be called directly via HTTP, you can also use the TypeScript SDK:

```ts title="admin-sdk.ts"
import { UserServiceImpl } from "@openauthjs/openauth/user"
import { D1UserAdapter } from "@openauthjs/openauth/user"

const userService = new UserServiceImpl({
  storage: env.KV,
  d1Adapter: new D1UserAdapter({ db: env.DB }),
})

// Create a user
const user = await userService.createUser("tenant_123", {
  email: "alice@example.com",
  name: "Alice Smith",
  metadata: { department: "Engineering" },
})

// List users with pagination
const { users, next_cursor, has_more } = await userService.listUsers("tenant_123", {
  limit: 50,
  status: "active",
  sort_by: "created_at",
  sort_order: "desc",
})
```

## Security Best Practices

1. **Secure Token Storage** - Store M2M client secrets securely (environment variables, secrets manager)
2. **Minimal Scopes** - Request only the scopes your application needs
3. **Token Rotation** - Rotate client secrets periodically
4. **Audit Logging** - Log all Admin API calls for compliance
5. **Network Security** - Restrict Admin API access to trusted networks when possible
