---
title: Sessions
description: Multi-account browser sessions with account switching.
---

Enterprise sessions enable users to be logged into multiple accounts simultaneously, similar to Google's multi-account feature.

## How It Works

Sessions are stored in an encrypted browser cookie (`__openauth_session`):

```
Browser Session
├── Account 0 (active)
│   ├── subject: "user"
│   ├── properties: { userID: "123" }
│   └── expiresAt: 1234567890
├── Account 1
│   ├── subject: "user"
│   ├── properties: { userID: "456" }
│   └── expiresAt: 1234567890
└── Account 2
    └── ...
```

- Maximum 3 concurrent accounts per browser
- Sliding window expiration (refreshed on activity)
- JWE encrypted with your signing key

## Configuration

```ts title="issuer.ts"
createMultiTenantIssuer({
  sessionConfig: {
    // Cookie name (default: __openauth_session)
    cookieName: "__openauth_session",

    // Session duration (default: 30 days)
    maxAge: 30 * 24 * 60 * 60 * 1000,

    // Max accounts per browser (default: 3)
    maxAccounts: 3,

    // Cookie options
    cookie: {
      secure: true,
      httpOnly: true,
      sameSite: "lax",
    },
  },
  // ...
})
```

## Session Routes

The enterprise issuer exposes session management endpoints:

```
GET  /session/check     Check session status
GET  /session/accounts  List all accounts in session
POST /session/switch    Switch active account
POST /session/remove    Remove account from session
POST /session/logout    Logout current account
POST /session/clear     Clear entire session
```

### Check Session

```ts
const response = await fetch("/session/check", {
  credentials: "include",
})

const { authenticated, account, accountCount } = await response.json()
// {
//   authenticated: true,
//   account: { subject: "user", properties: { userID: "123" } },
//   accountCount: 2
// }
```

### List Accounts

```ts
const response = await fetch("/session/accounts", {
  credentials: "include",
})

const { accounts, activeIndex } = await response.json()
// {
//   accounts: [
//     { subject: "user", properties: { userID: "123" } },
//     { subject: "user", properties: { userID: "456" } }
//   ],
//   activeIndex: 0
// }
```

### Switch Account

```ts
await fetch("/session/switch", {
  method: "POST",
  credentials: "include",
  headers: { "Content-Type": "application/json" },
  body: JSON.stringify({ index: 1 }),
})
```

### Add Account

To add another account, redirect to authorize with `prompt=login`:

```ts
const addAccountUrl = `/authorize?${new URLSearchParams({
  client_id: "your-client",
  redirect_uri: "https://app.example.com/callback",
  response_type: "code",
  prompt: "login", // Forces new login even if session exists
})}`

window.location.href = addAccountUrl
```

## OIDC Prompt Parameter

The enterprise issuer fully supports the OIDC `prompt` parameter:

| Value | Behavior |
|-------|----------|
| `none` | Silent auth - fail if no session |
| `login` | Force re-authentication |
| `consent` | Force consent screen |
| `select_account` | Show account picker |

```ts
// Silent authentication (check if logged in)
const silentAuthUrl = `/authorize?prompt=none&...`

// Force login (add new account)
const loginUrl = `/authorize?prompt=login&...`

// Account picker
const selectUrl = `/authorize?prompt=select_account&...`
```

### Account Picker Sign Out

When the account picker is displayed (`prompt=select_account`), users can sign out of individual accounts without leaving the authorization flow. Each account shows a "Sign out" button that:

1. Removes that account from the browser session
2. Keeps the user on the account picker with remaining accounts
3. Preserves the original authorization parameters (redirect_uri, state, etc.)

This allows users to clean up their session before selecting which account to use, similar to Google's account picker behavior.

## Session Service

For advanced use cases, use the session service directly:

```ts
import { SessionService } from "@openauthjs/openauth/session"

const sessionService = new SessionService(signingKey, config)

// Create session from request
const session = await sessionService.fromRequest(request)

// Add account to session
session.addAccount({
  subject: "user",
  properties: { userID: "789" },
})

// Switch active account
session.switchAccount(1)

// Get cookie header for response
const cookieHeader = await sessionService.toCookie(session)
```

## Session Analytics

The admin session service provides device tracking and session analytics.

### Session Info

Each session includes device metadata:

```ts
interface UserSessionInfo {
  id: string
  browser_session_id: string
  user_id: string
  is_active: boolean
  authenticated_at: number
  expires_at: number
  // Device info
  user_agent: string      // Browser/device identification
  ip_address: string      // Client IP address
  last_activity: number   // Last activity timestamp (ms)
}
```

### List User Sessions

View all active sessions for a user across devices:

```ts
import { AdminSessionService } from "@openauthjs/openauth/session"

const adminService = new AdminSessionService({ database: env.DB })

const sessions = await adminService.listUserSessions({
  userId: "user-123",
  tenantId: "tenant-1",
  limit: 50,
  offset: 0,
})

// Returns sessions with device info
sessions.forEach(session => {
  console.log(`Device: ${session.user_agent}`)
  console.log(`IP: ${session.ip_address}`)
  console.log(`Last active: ${new Date(session.last_activity)}`)
})
```

### Session Statistics

Get aggregate session metrics:

```ts
const stats = await adminService.getSessionStats({
  tenantId: "tenant-1", // Omit for global stats
})

// {
//   totalBrowserSessions: 1250,
//   totalAccountSessions: 3420,
//   activeSessions: 890,
//   activeSessionsLast24h: 450,
//   uniqueUsers: 780
// }
```

### Revoke Sessions

Terminate specific or all user sessions:

```ts
// Revoke specific session (logs out one device)
await adminService.revokeSession({
  sessionId: "session-abc",
  tenantId: "tenant-1",
})

// Revoke all sessions (force logout everywhere)
await adminService.revokeAllUserSessions({
  userId: "user-123",
  tenantId: "tenant-1",
})
```

### Admin API Endpoints

```
GET    /admin/users/:userId/sessions             - List user's sessions with device info
DELETE /admin/users/:userId/sessions/:sessionId  - Terminate specific session
DELETE /admin/users/:userId/sessions             - Terminate all user sessions
POST   /admin/users/:userId/force-logout         - Force logout everywhere
```

### Cleanup Expired Sessions

Scheduled maintenance to remove old sessions:

```ts
// Get expired sessions for review
const expired = await adminService.getExpiredSessions({
  maxAgeMs: 7 * 24 * 60 * 60 * 1000, // 7 days
  limit: 100,
})

// Cleanup expired sessions in batches
const result = await adminService.cleanupExpiredSessions({
  maxAgeMs: 7 * 24 * 60 * 60 * 1000,
  batchSize: 100,
})
console.log(`Deleted ${result.deletedCount} expired sessions`)
```

:::tip[Scheduled Cleanup]
Run `cleanupExpiredSessions` as a cron job or Cloudflare scheduled worker to prevent database bloat:
```ts
export default {
  async scheduled(event, env, ctx) {
    const adminService = new AdminSessionService({ database: env.DB })
    await adminService.cleanupExpiredSessions({ maxAgeMs: 7 * 24 * 60 * 60 * 1000 })
  }
}
```
:::
